<!doctype html><html lang="uk"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="HydroPump - автоматична помпа-дозатор води на базі Arduino з 3D друкованим корпусом"><title>HydroPump | Розумний дозатор води</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;600;700&family=Roboto:wght@400;500&display=swap" rel="stylesheet"><script src="https://cdn.tailwindcss.com"></script><link rel="stylesheet" href="style.css"><script>tailwind.config={theme:{extend:{colors:{"deep-blue":"#0A2463","ocean-blue":"#1E88E5",aqua:"#00BCD4","light-aqua":"#4DD0E1","water-dark":"#0D1B2A"},fontFamily:{poppins:["Poppins","sans-serif"],roboto:["Roboto","sans-serif"]}}}}</script></head><body class="bg-water-dark text-white"><canvas id="water-canvas"></canvas><div class="content-layer"><main class="flex flex-col items-center justify-center min-h-screen px-4"><a href="about.html" class="logo-button" aria-label="Дізнатись більше"><img src="assets/logo.jpg" alt="HydroPump Logo" class="logo-image"></a></main></div><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script><script>// Fullscreen Water Surface Effect
      const canvas = document.getElementById('water-canvas');
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      const renderer = new THREE.WebGLRenderer({ canvas, alpha: false, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      camera.position.set(0, 50, 100);
      camera.lookAt(0, 0, 0);

      // Create large water plane covering entire viewport
      const planeSize = 300;
      const segments = 256;
      const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize, segments, segments);

      // Custom shader material for realistic water
      const waterMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          colorDeep: { value: new THREE.Color(0x0a2463) },
          colorShallow: { value: new THREE.Color(0x1e88e5) },
          colorFoam: { value: new THREE.Color(0x4dd0e1) },
        },
        vertexShader: `
          uniform float time;
          varying vec2 vUv;
          varying float vElevation;

          void main() {
            vUv = uv;
            vec3 pos = position;

            // Multiple wave frequencies for realistic water
            float wave1 = sin(pos.x * 0.15 + time * 1.0) * 3.0;
            float wave2 = sin(pos.y * 0.12 + time * 0.7) * 3.5;
            float wave3 = sin(pos.x * 0.25 - pos.y * 0.2 + time * 1.3) * 2.5;
            float wave4 = cos(pos.x * 0.08 + pos.y * 0.15 - time * 0.6) * 2.8;
            float wave5 = sin(pos.x * 0.4 + pos.y * 0.3 + time * 1.8) * 1.5;

            float elevation = wave1 + wave2 + wave3 + wave4 + wave5;
            pos.z = elevation;

            vElevation = elevation;

            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 colorDeep;
          uniform vec3 colorShallow;
          uniform vec3 colorFoam;
          varying vec2 vUv;
          varying float vElevation;

          void main() {
            float mixStrength = (vElevation + 8.0) / 16.0;
            mixStrength = clamp(mixStrength, 0.0, 1.0);

            vec3 color = mix(colorDeep, colorShallow, mixStrength);

            // Add foam on wave peaks
            if (vElevation > 6.0) {
              float foamStrength = (vElevation - 6.0) / 4.0;
              color = mix(color, colorFoam, foamStrength * 0.5);
            }

            gl_FragColor = vec4(color, 1.0);
          }
        `,
        side: THREE.DoubleSide,
      });

      const waterPlane = new THREE.Mesh(planeGeometry, waterMaterial);
      waterPlane.rotation.x = -Math.PI / 3;
      waterPlane.position.y = -30;
      scene.add(waterPlane);

      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0x1e88e5, 0.6);
      scene.add(ambientLight);

      // Add directional light for water highlights
      const dirLight = new THREE.DirectionalLight(0x4dd0e1, 0.8);
      dirLight.position.set(50, 80, 50);
      scene.add(dirLight);

      // Animation loop
      let time = 0;
      function animate() {
        requestAnimationFrame(animate);
        time += 0.012;

        // Update water shader
        waterMaterial.uniforms.time.value = time;

        // Gentle rotation of water plane
        waterPlane.rotation.z = Math.sin(time * 0.08) * 0.015;

        renderer.render(scene, camera);
      }

      animate();

      // Handle resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });</script></body></html>