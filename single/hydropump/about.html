<!doctype html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Про проєкт HydroPump - автоматичну помпу-дозатор води" />
    <title>HydroPump | Про проєкт</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;600;700&family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="style.css" />
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'deep-blue': '#0A2463',
              'ocean-blue': '#1E88E5',
              aqua: '#00BCD4',
              'light-aqua': '#4DD0E1',
              'water-dark': '#0D1B2A',
            },
            fontFamily: { poppins: ['Poppins', 'sans-serif'], roboto: ['Roboto', 'sans-serif'] },
          },
        },
      };
    </script>
  </head>
  <body class="bg-water-dark text-white">
    <canvas id="water-canvas"></canvas>
    <div class="content-layer">
      <main class="flex flex-col items-center justify-start min-h-screen px-4 py-12 w-full">
        <div class="w-full max-w-6xl flex items-start mb-6">
          <a href="index.html" class="back-button small" aria-label="Назад">←</a>
        </div>
        <header class="text-center mb-12">
          <h1 class="text-5xl md:text-6xl font-poppins font-bold mb-4 water-gradient-text">
            Проєкт HydroPump
          </h1>
          <p class="water-tagline">Розумний дозатор води</p>
        </header>

        <!-- Tabs -->
        <div class="tabs-container w-full max-w-6xl">
          <button class="tab-button active" data-tab="presentation">Презентація</button>
          <button class="tab-button" data-tab="details">Деталі проєкту</button>
        </div>

        <!-- Presentation Tab -->
        <section id="presentation" class="tab-content active w-full flex justify-center mb-12">
          <div class="slideshow-container" id="slideshow">
            <img
              src="assets/slide1.svg"
              alt="Слайд презентації"
              class="slide-img"
              id="slide-image"
            />
            <button class="slideshow-prev" id="slide-prev" aria-label="Попередній слайд">‹</button>
            <button class="slideshow-next" id="slide-next" aria-label="Наступний слайд">›</button>
          </div>
        </section>

        <!-- Project Details Tab -->
        <section id="details" class="tab-content w-full max-w-6xl px-4">
          <div class="project-details">
            <div class="details-grid">
              <div class="detail-card">
                <h3>Опис проєкту</h3>
                <p>
                  HydroPump — це автоматична помпа-дозатор води, розроблена студентами на базі
                  Arduino. Пристрій автоматично дозує воду порціями по одному стакану, що робить
                  його зручним для використання вдома, в офісі або навчальних закладах.
                </p>
              </div>

              <div class="detail-card">
                <h3>Технології</h3>
                <ul>
                  <li>Arduino (мікроконтролер)</li>
                  <li>Водяна помпа</li>
                  <li>Датчики рівня води</li>
                  <li>3D друкований корпус</li>
                  <li>Система управління дозуванням</li>
                </ul>
              </div>

              <div class="detail-card">
                <h3>Особливості</h3>
                <ul>
                  <li>Автоматичне дозування по стакану</li>
                  <li>Енергоефективність</li>
                  <li>Компактний дизайн</li>
                  <li>Легке обслуговування</li>
                  <li>Програмована логіка роботи</li>
                </ul>
              </div>

              <div class="detail-card">
                <h3>Реалізація</h3>
                <p>
                  Корпус пристрою було змодельовано та виготовлено за допомогою 3D друку, що
                  дозволило створити компактну та функціональну конструкцію. Програмне забезпечення
                  написане на C++ для платформи Arduino, забезпечує точне управління процесом
                  дозування води.
                </p>
              </div>

              <div class="detail-card">
                <h3>Команда</h3>
                <p>
                  Проєкт розроблений студентами в рамках навчальної програми з робототехніки та IoT.
                  Команда працювала над усіма аспектами: від проєктування механіки до програмування
                  логіки керування.
                </p>
              </div>

              <div class="detail-card">
                <h3>Перспективи розвитку</h3>
                <ul>
                  <li>Додавання дисплея для відображення інформації</li>
                  <li>Інтеграція з мобільним додатком</li>
                  <li>Підтримка різних обсягів дозування</li>
                  <li>Система фільтрації води</li>
                  <li>Датчики температури води</li>
                </ul>
              </div>
            </div>
          </div>
        </section>

        <footer class="text-center opacity-70 mt-8 mb-4">
          <p class="text-sm text-light-aqua">© 2025 Проєкт HydroPump</p>
        </footer>
      </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Water wave animation (same as index.html)
      const canvas = document.getElementById('water-canvas');
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      camera.position.z = 50;

      const particleCount = 3000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 200;
        positions[i + 1] = (Math.random() - 0.5) * 200;
        positions[i + 2] = (Math.random() - 0.5) * 100;

        const colorChoice = Math.random();
        if (colorChoice < 0.33) {
          colors[i] = 0.06;
          colors[i + 1] = 0.54;
          colors[i + 2] = 0.89;
        } else if (colorChoice < 0.66) {
          colors[i] = 0.0;
          colors[i + 1] = 0.74;
          colors[i + 2] = 0.83;
        } else {
          colors[i] = 0.3;
          colors[i + 1] = 0.81;
          colors[i + 2] = 0.88;
        }
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 2,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      let animationTime = 0;
      function animate() {
        requestAnimationFrame(animate);
        animationTime += 0.005;

        const positions = particles.geometry.attributes.position.array;

        for (let i = 0; i < particleCount * 3; i += 3) {
          const x = positions[i];
          const z = positions[i + 2];

          positions[i + 1] += Math.sin(animationTime + x * 0.05) * 0.3;
          positions[i + 1] += Math.cos(animationTime + z * 0.05) * 0.2;

          if (positions[i + 1] > 100) {
            positions[i + 1] = -100;
          }
          if (positions[i + 1] < -100) {
            positions[i + 1] = 100;
          }
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.rotation.y += 0.0005;

        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Tab switching
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');

      tabButtons.forEach((button) => {
        button.addEventListener('click', () => {
          const targetTab = button.getAttribute('data-tab');

          tabButtons.forEach((btn) => btn.classList.remove('active'));
          tabContents.forEach((content) => content.classList.remove('active'));

          button.classList.add('active');
          document.getElementById(targetTab).classList.add('active');
        });
      });

      // Slideshow functionality
      const slideImages = [
        'assets/slide1.svg',
        'assets/slide2.svg',
        'assets/slide3.svg',
        'assets/slide4.svg',
        'assets/slide5.svg',
      ];

      let currentSlideIndex = 0;
      const slideImage = document.getElementById('slide-image');
      const prevButton = document.getElementById('slide-prev');
      const nextButton = document.getElementById('slide-next');

      function showSlide(index) {
        if (index < 0) {
          currentSlideIndex = slideImages.length - 1;
        } else if (index >= slideImages.length) {
          currentSlideIndex = 0;
        } else {
          currentSlideIndex = index;
        }
        slideImage.src = slideImages[currentSlideIndex];
      }

      prevButton.addEventListener('click', () => {
        showSlide(currentSlideIndex - 1);
      });

      nextButton.addEventListener('click', () => {
        showSlide(currentSlideIndex + 1);
      });

      // Optional: Auto-advance slides
      let autoSlideInterval = setInterval(() => {
        showSlide(currentSlideIndex + 1);
      }, 5000);

      // Pause auto-advance on manual navigation
      [prevButton, nextButton].forEach((btn) => {
        btn.addEventListener('click', () => {
          clearInterval(autoSlideInterval);
          autoSlideInterval = setInterval(() => {
            showSlide(currentSlideIndex + 1);
          }, 5000);
        });
      });
    </script>
  </body>
</html>
