{
  "track": "sp",
  "lectureNumber": "1",
  "lectureTitle": "Огляд системного програмування",
  "courseTitle": "Спеціалізовані мови програмування",
  "year": "2025",
  "slides": [
    {
      "type": "title",
      "title": "ЛЕКЦІЯ 1",
      "subtitle": "Огляд системного програмування",
      "meta": { "course": "Спеціалізовані мови програмування", "institution": "VTFK • 2025" }
    },
    {
      "type": "roadmap",
      "title": "План лекції",
      "items": [
        "Системне програмування: визначення",
        "C, Rust, Assembly — порівняння",
        "Архітектура комп'ютера",
        "Навіщо вчити низькорівневе"
      ],
      "note": "Фокус: від теорії до практики"
    },
    {
      "type": "definition",
      "title": "Системне програмування",
      "term": "System Programming",
      "definition": "Розробка програм, які взаємодіють прямо з апаратурою: операційні системи, драйвери, компілятори, базові утиліти.",
      "analogy": "Як архітектор будівель розуміє не тільки дизайн, але й основу, фундамент, конструкцію"
    },
    {
      "type": "content",
      "title": "Три рівні абстракції",
      "text": "Від високого до низького",
      "items": [
        "Високий рівень: Python, JavaScript (швидка розробка)",
        "Системний рівень: C, Rust (контроль + безпека)",
        "Апаратний рівень: Assembly, Machine Code (максимальна продуктивність)"
      ]
    },
    {
      "type": "diagram",
      "title": "Рівні програмування",
      "description": "Абстракція і контроль",
      "mermaidCode": "%%{init: {\"theme\": \"neutral\", \"mermaid\": {\"version\": \"11.12.2\"}}}%%\ngraph LR\n  App[\"Додатки<br/>Python, JS\"] -->|calls| OS[\"ОС<br/>Linux/Windows<br/>C, Rust\"]\n  OS -->|calls| HW[\"Апаратура<br/>Assembly<br/>x86-64\"]\n  \n  Dev1[\"High-level\"] -.-> App\n  Dev2[\"System-level\"] -.-> OS\n  Dev3[\"Low-level\"] -.-> HW\n  \n  style App fill:#E5F3FF\n  style OS fill:#FFE5E5\n  style HW fill:#FFE5FF"
    },
    {
      "type": "table",
      "title": "Мови системного програмування",
      "headers": ["Мова", "Рівень", "Безпека", "Продуктивність", "Крива навчання"],
      "rows": [
        ["C", "Низький", "Ручна", "Дуже висока", "Висока"],
        ["Rust", "Низький", "Автоматична", "Висока", "Дуже висока"],
        ["Assembly", "Дуже низький", "Немає", "Максимальна", "Найвища"],
        ["Python", "Високий", "Автоматична", "Низька", "Низька"]
      ]
    },
    {
      "type": "content",
      "title": "Який файл як вибрати?",
      "text": "Залежить від завдання",
      "items": [
        "C: коли потрібна продуктивність + портативність (Linux kernel, СУБД)",
        "Rust: коли потрібна безпека (системи реального часу, безпека пам'яті)",
        "Assembly: коли потрібна максимальна оптимізація (критичні цикли, bootloader)"
      ]
    },
    {
      "type": "code-example",
      "title": "Той самий код: три мови",
      "description": "Додавання двох чисел",
      "language": "c",
      "code": "// C: контроль над всім\n#include <stdio.h>\n\nint main() {\n    int a = 5, b = 3;\n    int sum = a + b;  // + в C = одна машинна інструкція\n    printf(\"%d\\n\", sum);\n    return 0;\n}\n\n// Результат: 8"
    },
    {
      "type": "code-example",
      "title": "Той самий код: Rust",
      "description": "Безпечніше, але більше синтаксису",
      "language": "rust",
      "code": "// Rust: безпека + контроль\nfn main() {\n    let a = 5;\n    let b = 3;\n    let sum = a + b;  // Компілятор перевіряє типи\n    println!(\"{}\", sum);\n}\n\n// Результат: 8"
    },
    {
      "type": "code-example",
      "title": "Той самий код: Assembly (x86-64)",
      "description": "Машина говорить нам",
      "language": "nasm",
      "code": "; Assembly: абсолютний контроль\nmov rax, 5      ; rax = 5\nmov rbx, 3      ; rbx = 3\nadd rax, rbx    ; rax = rax + rbx (8)\n; Результат у rax: 8"
    },
    {
      "type": "diagram",
      "title": "Як код стає бітами",
      "description": "Шлях компіляції",
      "mermaidCode": "%%{init: {\"theme\": \"neutral\", \"mermaid\": {\"version\": \"11.12.2\"}}}%%\nflowchart LR\n  Source[\"C код<br/>main.c\"] --> Compiler[\"Компілятор<br/>gcc/clang\"]\n  Compiler --> ASM[\"Assembly<br/>main.s\"]\n  ASM --> Assembler[\"Асемблер<br/>as\"]\n  Assembler --> OBJ[\"Об'єктний файл<br/>main.o\"]\n  OBJ --> Linker[\"Лінкер<br/>ld\"]\n  Linker --> BIN[\"Виконавець<br/>./main\"]\n  BIN --> CPU[\"CPU<br/>виконує\"]\n  \n  style Source fill:#E5F3FF\n  style BIN fill:#FFE5E5\n  style CPU fill:#FFE5FF"
    },
    {
      "type": "list",
      "title": "Чому системне програмування важливо?",
      "items": [
        { "title": "Продуктивність", "details": ["ОС, БД, браузери — написано на C/Rust"] },
        { "title": "Безпека", "details": ["Rust запобігає помилкам пам'яті на етапі компіляції"] },
        { "title": "Розуміння", "details": ["Як насправді працює комп'ютер"] },
        { "title": "Кар'єра", "details": ["Краща зарплата, престижніші компанії"] }
      ]
    },
    {
      "type": "content",
      "title": "Архітектура: коротко",
      "text": "Ми фокусуватимось на x86-64",
      "items": [
        "CPU: виконує інструкції",
        "Регістри: надшвидка пам'ять (rax, rbx, rcx...)",
        "RAM: повільніша, але більша пам'ять",
        "Складність: інструкції мають побічні ефекти (прапорці)"
      ]
    },
    {
      "type": "quiz",
      "title": "Міні-вікторина",
      "question": "Яка різниця між C та Assembly?",
      "options": [
        { "text": "Немає — Assembly швидше", "correct": false },
        { "text": "C — переносима, Assembly — архітектурна", "correct": true },
        { "text": "Assembly безпечніший", "correct": false }
      ],
      "explanation": "Assembly для x86-64 не працює на ARM. C — зв'язок між логікою та машиною."
    },
    {
      "type": "common-mistake",
      "title": "Помилка: мислити 'C = Assembly'",
      "warning": "C часто простіший, ніж Assembly, та переносимий",
      "language": "c",
      "wrongCode": "// Я писатиму Assembly\n// щоб мій код був швидшим\nint c_version() { return 5 + 3; }",
      "wrongExplanation": "Сучасні компілятори (gcc -O3) генерують ідентичний Assembly",
      "correctCode": "// Пиши на C/Rust першим\n// Оптимізуй тільки вузькі місця\n// Профілюй інструментами: perf, valgrind",
      "correctExplanation": "Правило 80/20: 80% часу у 20% коду"
    },
    {
      "type": "content",
      "title": "Модулі цього курсу",
      "text": "Що вивчимо",
      "items": [
        "Модуль 1 (Лекції 1-4): Вступ, системи числення, архітектура, інструменти",
        "Модуль 2 (Лекції 5-8): NASM основи, інструкції, пам'ять",
        "Модуль 3 (Лекції 9-12): Rust вступ, базові концепції",
        "Модуль 4 (Лекції 13-16): Rust глибше: ownership, borrowing, типи",
        "Модуль 5 (Лекції 17-20): Rust продвинуто: колекції, модулі, traits",
        "Модуль 6 (Лекції 21-23): Docker і контейнеризація"
      ]
    },
    {
      "type": "summary",
      "title": "Підсумки",
      "items": [
        "Системне програмування — взаємодія з апаратурою",
        "C — компроміс між контролем і переносимістю",
        "Rust — сучасна альтернатива з гарантіями безпеки"
      ],
      "note": "Далі — системи числення"
    },
    {
      "type": "next-steps",
      "title": "Домашнє завдання",
      "nextLecture": "Лекція 2: Системи числення",
      "resources": [
        {
          "title": "The Art of Computer Systems Programming",
          "url": "https://en.wikipedia.org/wiki/Systems_programming"
        },
        { "title": "Why Rust?", "url": "https://www.rust-lang.org/what/why-rust/" }
      ],
      "homework": [
        "Установи GCC, Rust, NASM на свій комп'ютер",
        "Напиши Hello World на C, Rust, та Assembly",
        "Порівняй розмір цих програм (size ./program)"
      ]
    }
  ]
}
